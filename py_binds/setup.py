from setuptools import Extension, setup
from Cython.Build import cythonize
import os
import platform
import numpy
import shutil


########################################################################################################################
# definition function returning the extension specification for the Passenger Vehicle class
########################################################################################################################
def prepare_PassengerVehicle(relPathPyBinds, dirBuild_PassengerVehicle, relPathBuild_PassengerVehicle):

    # Source files for Cython wrapper class
    source_files = [os.path.join(relPathPyBinds, 'PassengerVehicle.pyx'),
                    os.path.join(relPathPyBinds, 'src', 'PassengerVehicleWrapper.cpp')]

    # Include directories for Cython wrapper class and Matlab
    include_dirs = [numpy.get_include(),
                    os.path.join(relPathPyBinds, 'src'),
                    os.path.join(relPathPyBinds, 'PassengerVehicle', 'R2018b', 'extern', 'include'),
                    os.path.join(relPathPyBinds, 'PassengerVehicle', 'R2018b', 'simulink', 'include'),
                    os.path.join(relPathPyBinds, 'PassengerVehicle', 'R2018b', 'rtw', 'c', 'src'),
                    os.path.join(relPathPyBinds, 'PassengerVehicle', 'R2018b', 'rtw', 'c', 'src', 'ext_mode', 'common')]

    # compiler flags
    if platform.system() == 'Windows':
        compile_args = []
    elif platform.system() == 'Linux':
        compile_args = ['-fpermissive', '-w', '-std=c++11']
    else:
        raise OSError('System not identified!')

    # Source files and include directories from code generated by Simulink
    extension_source = ".cpp"
    extension_header = ".h"
    for root, dirs, files in os.walk(dirBuild_PassengerVehicle):
        for file in files:
            rel_dir = os.path.relpath(root, dirBuild_PassengerVehicle)
            if file.endswith(extension_source):
                source_files.append(os.path.join(relPathBuild_PassengerVehicle, rel_dir, file))
            if file.endswith(extension_header):
                include_dirs.append(os.path.join(relPathBuild_PassengerVehicle, rel_dir))

    # prepare everything as python extension module
    PassengerVehicleExtension = Extension(name="PassengerVehicle",
                                           sources=source_files,
                                           include_dirs=include_dirs,
                                           language="c++",
                                           extra_compile_args=compile_args)

    return PassengerVehicleExtension

########################################################################################################################
# definition function returning the extension specification for the single-track model class
########################################################################################################################
def prepare_SingleTrackModel(relPathPyBinds, dirBuild_SingleTrackModel, relPathBuild_SingleTrackModel):

    # Source files for Cython wrapper class
    source_files = [os.path.join(relPathPyBinds, 'SingleTrackModel.pyx'),
                    os.path.join(relPathPyBinds, 'src', 'SingleTrackModelWrapper.cpp')]

    # Include directories for Cython wrapper class and Matlab
    include_dirs = [numpy.get_include(),
                    os.path.join(relPathPyBinds, 'src'),
                    os.path.join(relPathPyBinds, 'SingleTrackModel', 'R2018b', 'extern', 'include'),
                    os.path.join(relPathPyBinds, 'SingleTrackModel', 'R2018b', 'simulink', 'include'),
                    os.path.join(relPathPyBinds, 'SingleTrackModel', 'R2018b', 'rtw', 'c', 'src'),
                    os.path.join(relPathPyBinds, 'SingleTrackModel', 'R2018b', 'rtw', 'c', 'src', 'ext_mode', 'common')]

    # compiler flags
    if platform.system() == 'Windows':
        compile_args = []
    elif platform.system() == 'Linux':
        compile_args = ['-fpermissive', '-w', '-std=c++11']
    else:
        raise OSError('System not identified!')

    # Source files and include directories from code generated by Simulink
    extension_source = ".cpp"
    extension_header = ".h"
    for root, dirs, files in os.walk(dirBuild_SingleTrackModel):
        for file in files:
            rel_dir = os.path.relpath(root, dirBuild_SingleTrackModel)
            if file.endswith(extension_source):
                source_files.append(os.path.join(relPathBuild_SingleTrackModel, rel_dir, file))
            if file.endswith(extension_header):
                include_dirs.append(os.path.join(relPathBuild_SingleTrackModel, rel_dir))

    # prepare everything as python extension module
    SingleTrackModelExtension = Extension(name="SingleTrackModel",
                                           sources=source_files,
                                           include_dirs=include_dirs,
                                           language="c++",
                                           extra_compile_args=compile_args)

    return SingleTrackModelExtension

########################################################################################################################
# definition function returning the extension specification for the double-track model class
########################################################################################################################
def prepare_DoubleTrackModel(relPathPyBinds, dirBuild_DoubleTrackModel, relPathBuild_DoubleTrackModel):

    # Source files for Cython wrapper class
    source_files = [os.path.join(relPathPyBinds, 'DoubleTrackModel.pyx'),
                    os.path.join(relPathPyBinds, 'src', 'DoubleTrackModelWrapper.cpp')]

    # Include directories for Cython wrapper class and Matlab
    include_dirs = [numpy.get_include(),
                    os.path.join(relPathPyBinds, 'src'),
                    os.path.join(relPathPyBinds, 'DoubleTrackModel', 'R2018b', 'extern', 'include'),
                    os.path.join(relPathPyBinds, 'DoubleTrackModel', 'R2018b', 'simulink', 'include'),
                    os.path.join(relPathPyBinds, 'DoubleTrackModel', 'R2018b', 'rtw', 'c', 'src'),
                    os.path.join(relPathPyBinds, 'DoubleTrackModel', 'R2018b', 'rtw', 'c', 'src', 'ext_mode', 'common')]

    # compiler flags
    if platform.system() == 'Windows':
        compile_args = []
    elif platform.system() == 'Linux':
        compile_args = ['-fpermissive', '-w', '-std=c++11']
    else:
        raise OSError('System not identified!')

    # Source files and include directories from code generated by Simulink
    extension_source = ".cpp"
    extension_header = ".h"
    for root, dirs, files in os.walk(dirBuild_DoubleTrackModel):
        for file in files:
            rel_dir = os.path.relpath(root, dirBuild_DoubleTrackModel)
            if file.endswith(extension_source):
                source_files.append(os.path.join(relPathBuild_DoubleTrackModel, rel_dir, file))
            if file.endswith(extension_header):
                include_dirs.append(os.path.join(relPathBuild_DoubleTrackModel, rel_dir))

    # prepare everything as python extension module
    DoubleTrackModelExtension = Extension(name="DoubleTrackModel",
                                           sources=source_files,
                                           include_dirs=include_dirs,
                                           language="c++",
                                           extra_compile_args=compile_args)

    return DoubleTrackModelExtension

########################################################################################################################
# prepare and find paths
########################################################################################################################
# Current working directory
dirCurrent = os.path.abspath(os.getcwd())
# Build directory
dirBuild_PassengerVehicle = os.path.abspath(os.path.join(os.path.abspath(__file__), '..', 'tum_vehdyn', 'PassengerVehicle', 'build'))
dirBuild_SingleTrackModel = os.path.abspath(os.path.join(os.path.abspath(__file__), '..', 'tum_vehdyn', 'SingleTrackModel', 'build'))
dirBuild_DoubleTrackModel = os.path.abspath(os.path.join(os.path.abspath(__file__), '..', 'tum_vehdyn', 'DoubleTrackModel', 'build'))
# Relative paths to build directories
relPathBuild_PassengerVehicle = os.path.relpath(dirBuild_PassengerVehicle, dirCurrent)
relPathBuild_SingleTrackModel = os.path.relpath(dirBuild_SingleTrackModel, dirCurrent)
relPathBuild_DoubleTrackModel = os.path.relpath(dirBuild_DoubleTrackModel, dirCurrent)
# Relative path to bindings
relPathPyBinds = os.path.relpath(os.path.join(os.path.abspath(__file__), '../tum_vehdyn'), dirCurrent)
# directory of cython definition files:
definition_files_dir = [os.path.join(relPathPyBinds, 'definition_files')]

########################################################################################################################
# setup and compile cython modules
########################################################################################################################
# get all extensions
PassengerVehicle_ext = prepare_PassengerVehicle(relPathPyBinds, dirBuild_PassengerVehicle, relPathBuild_PassengerVehicle)
SingleTrackModel_ext = prepare_SingleTrackModel(relPathPyBinds, dirBuild_SingleTrackModel, relPathBuild_SingleTrackModel)
DoubleTrackModel_ext = prepare_DoubleTrackModel(relPathPyBinds, dirBuild_DoubleTrackModel, relPathBuild_DoubleTrackModel)

# list all required extensions
cython_extensions = [PassengerVehicle_ext, SingleTrackModel_ext, DoubleTrackModel_ext]

setup(
    name="tum_vehicle_dynamics",
    version="0.0.3",
    install_requires=['numpy'],
    ext_modules=cythonize(cython_extensions,
    include_path=definition_files_dir,
    compiler_directives={'language_level': "3"}),
    packages=['tum_vehdyn'],
    package_data={'tum_vehdyn': ['data/*',
                              'data/params/*']},
    entry_points={
        'console_scripts': [
            'pasveh_driving = tum_vehdyn.examples.VehicleDynamics:main'
        ]}
      )
